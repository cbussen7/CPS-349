# -*- coding: utf-8 -*-
"""assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t6NJd2XtMf3YZdHJKL2K6c-vCriCuOz7
"""

# One of the dataset issues I could see persisting with this dataset is the fact that housing median age does not necessarily describe how good of
# condition a house is in. This is because we do not know how the house has been treated or if it has recently been renovated, which could greatly
# impact the value of a house. Another problem with the dataset that I think could get in the way of valuable insights is that <1 hour from the
# ocean is a pretty broad category. In my limited experience, a house in California that is 55 minutes from the ocean might be noticeably less
# expensive than one that is 25 minutes from the ocean. Additionally, I might've somehow missed this in the description but I looked several times
# to see if it clarified the differences between the categories (i.e., <1 H and near ocean) but I could not find anything. One final issue I could
# see persisting is that rooms can sometimes be somewhat hard to define in certain houses. By this, I mean that some houses are more open than
# others and rooms freely flow into each other, so the number of rooms in a house is not always black and white. Instead, it can be up to
# interpretation which could affect the data (again, this is unless there is some hard set definition of a room that I don't know about).

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

# 1. Load the dataset into a Pandas DataFrame. (1 pts)
train = pd.read_csv("housing.csv")

# 2. Print out all the data in the first 5 and last 5 rows. (2 pts)
print(train.head())
print(train.tail())

# 3. Print out the type, Non-Null count, and name of each column. (2 pts)
print(train.info())

# 4. Write at least 3 of the potential dataset biases or issues you could see persisting, in a multi-line
# comment at the top of your program. (2 pts)
# DONE AT TOP OF PROGRAM

# 5. Print the count, mean, standard deviation, minimum, 25%, 50%, 75%, and maximum values
# of all the radial data. (2 pts)
print(train.describe())

# 6. Print out the count, unique count, mode, and frequency of the mode of the ordinal and
# nominal data (all have the Pandas type as object) (1 pt)
print(train.describe(include=["O"]))

# 7. Plot a histogram of each numerical value in a single figure using subplots, or the hist() function
# in Pandas (much easier option of the two, needs just one line). (2 pt)
print(train.hist(bins=25, figsize=(20,15)))

# 8. Print the mean “median house value” grouped by the “median age” in sorted order. (2 pt)
print(train[['housing_median_age', 'median_house_value']].groupby(['housing_median_age']).mean())

# train[['housing_median_age', 'median_house_value']].sort_values(by='housing_median_age') -- used this to check if 1 was right

# 9. Plot every latitude and longitude in a scatter plot. (2 pts)
# grid = sns.FacetGrid(train)
# grid.map(sns.pointplot, 'latitude', 'longitude', palette='deep')

# train.plot.scatter('latitude', 'longitude')

# sns.pointplot(data=train, x='latitude', y='longitude')
# above are different ways I experimented with doing this
print(sns.scatterplot(data=train, x='latitude', y='longitude'))

# 10. Using Seaborn, plot a histogram of “median house value” with columns for each value of
# “ocean proximity”. (1 pt)
hist = sns.FacetGrid(train, col='ocean_proximity')
print(hist.map(plt.hist, 'median_house_value'))

# 11. Plot every latitude and longitude in a scatter plot, with the point weight being their value
# for “median house value”. (1 pt)
print(sns.scatterplot(data=train, x='latitude', y='longitude', size='median_house_value'))

# 12. Create a temporary DataFrame, and remove all rows that are not “<1H Ocean”. It should
# now be the only category remaining in this temporary DataFrame. Now, scatter plot all of
# these latitudes and longitudes, with the “median house value” as the point weight. (2 pts)
# len(train[train['ocean_proximity'] == '<1H OCEAN']) -- used to check that right amount of values were removed
temp_df = train.drop(train[train['ocean_proximity'] != '<1H OCEAN'].index)
temp_df.info()

print(sns.scatterplot(data=temp_df, x='latitude', y='longitude', size='median_house_value'))

# 13. Re-using the temporary DataFrame made in the last question, apply a mask to remove any
# “median house values” under 300,000. Plot the now masked latitude and longitudes as a
# scatter plot, again with point weight being the “median house value”. You will no longer use
# the temporary DataFrame after this question. (2 pts)
# len(temp_df[temp_df['median_house_value'] < 300000]) -- used to check for correct amount of values
# temp_df.mask(temp_df['median_house_value'] < 300000)
print(sns.scatterplot(data=temp_df.mask(temp_df['median_house_value'] < 300000), x='latitude', y='longitude', size='median_house_value'))

# 14. Create and add a new column to the original DataFrame that is the “rooms per household”,
# by using the “total bedrooms” and “households” columns. Now, create a second new column
# for the “rooms per population” by using the “total rooms” and “population” columns, to see
# how many rooms each person gets on average. (2 pts).
train['rooms_per_household'] = train['total_bedrooms'] / train['households']
train.head()

train['rooms_per_population'] = train['total_rooms'] / train['population']
train.head()

# 15. Print the correlation matrix, in ascending order, of the “median hose value”. (2 pts)
print(train.corr()['median_house_value'].sort_values())

# 16. Remove the “total bedrooms” column completely from the DataFrame. (2 pts)
train.drop('total_bedrooms', axis=1, inplace=True)
train.info()

# 17. Finally, remove the 4 columns you find least important to predict the “median house value”.
# You should in total have 7 total columns left, including “median house value”. (2 pts)
train.drop('housing_median_age', axis=1, inplace=True)
train.drop('households', axis=1, inplace=True)
train.drop('total_rooms', axis=1, inplace=True)
train.drop('ocean_proximity', axis=1, inplace=True)

train.info()